- Ensure every code modification strictly preserves correctness, minimality of change, and robustly handles edge/corner cases related to the problem statement—even in complex, inherited, or nested code structures.
- Avoid blanket or “quick fix” solutions that might hide errors or unintentionally discard critical information; always strive to diagnose and address root-causes, not merely symptoms or side-effects.
- Where input normalization is necessary—for types, iterables, containers, or input shapes—do so only in a way that preserves API contracts, allows for extensibility, and maintains invariance across all supported data types, including Python built-ins and major library types (e.g., numpy, pandas, namedtuples, Django QuerySets).
- Updates to serialization, deserialization, or pickling must make objects fully serializable while preserving invariants and intended round-trip behavior; never silence or “skip” non-serializable data in ways that break functionality or state restoration.
- All error/warning messages, exceptions, and documentation updates must be technically accurate, actionable, match the conventions of the host codebase, and be kept fully in sync with new or changed behavior.
- Backwards and forwards compatibility: Changes must account for code used in diverse environments (e.g., different Python versions, framework/ORM versions, or platforms), and leverage feature detection where possible to avoid breaking downstream or legacy code.
- When adding or modifying logic for type-checking or data validation, ensure broad compatibility (accepting user-extensible or duck-typed objects), and do not rely solely on type equality — instead, prefer robust protocols and standard ABCs from collections.abc or numbers.
- Refactorings and bugfixes must never silently discard, mask, or change user data, hooks, plugin registrations, or extension points; if a migration or transformation is required, ensure it is invertible where possible and preserves optional hooks or entry points.
- Order and determinism: Any operation that outputs an ordered structure (lists, sets, dicts, serialized output, etc.) must be fully deterministic and canonical, avoiding reliance on implementation details such as hash or iteration order.
- When fixing inadequacies in code generation or code rewriting (such as AST manipulations or doc generation), ensure generated and round-tripped output remains structurally identical to what a human developer would expect, with round-trip tests for edge cases.
- In all changes, explicitly propagate undefined, error, or exceptional states and do not assume the operation can proceed with a fallback value—raise the appropriate error or preserve “undefined” sentinel values as dictated by project and mathematical conventions.
- Any new or altered logic involving introspection, hooks, or extensibility APIs must continue to delegate or respect user-overridable methods, callables, and plugin contracts, and must not unilaterally “hardcode” or shadow such points of extension.
- Data structure or state mutation during iteration must detect and raise errors as per Python's standard idioms, rather than silently accepting or attempting to continue.
- For any performance optimization or auto-detection logic, ensure it does not cause information loss, break invariants, or introduce surprising side effects for end users, especially in iterative, batched, or chained computation modes.
- Comprehensive test coverage is required for new or edge-case behaviors introduced by the patch, including round-trip scenarios and regressions for all known variations, but test logic must not become overly coupled to implementation details. 
- Each code update or fix must preserve the documented and idiomatic API for that host framework or project (Django, Scikit-Learn, SymPy, Matplotlib, Sphinx, etc.)—never change function signatures or public class inheritance without a compelling and documented technical justification.
- Never introduce redundant, unrelated, or global changes that are not strictly motivated by the core requirement or could result in maintainability challenges or cryptic regressions in unrelated modules.
- Be mindful when updating or relying on language- or platform-specific features (e.g., Python minor version features, framework-specific object protocols); provide backwards-compatible handling whenever feasible to serve users across the supported ecosystem.
- When applying deduplication, grouping, or normalization logic to user inputs or internal state, always use stable and canonical ordering and minimize the potential for data loss, regression, or ambiguity—mirror the semantics expected by users and the broader community.- Ensure every code modification strictly preserves correctness, minimality of change, and robustly handles edge/corner cases related to the problem statement—even in complex, inherited, or nested code structures.
- Avoid blanket or “quick fix” solutions that might hide errors or unintentionally discard critical information; always strive to diagnose and address root-causes, not merely symptoms or side-effects.
- Where input normalization is necessary—for types, iterables, containers, or input shapes—do so only in a way that preserves API contracts, allows for extensibility, and maintains invariance across all supported data types, including Python built-ins and major library types (e.g., numpy, pandas, namedtuples, Django QuerySets).
- Updates to serialization, deserialization, or pickling must make objects fully serializable while preserving invariants and intended round-trip behavior; never silence or “skip” non-serializable data in ways that break functionality or state restoration.
- All error/warning messages, exceptions, and documentation updates must be technically accurate, actionable, match the conventions of the host codebase, and be kept fully in sync with new or changed behavior.
- Backwards and forwards compatibility: Changes must account for code used in diverse environments (e.g., different Python versions, framework/ORM versions, or platforms), and leverage feature detection where possible to avoid breaking downstream or legacy code.
- When adding or modifying logic for type-checking or data validation, ensure broad compatibility (accepting user-extensible or duck-typed objects), and do not rely solely on type equality — instead, prefer robust protocols and standard ABCs from collections.abc or numbers.
- Refactorings and bugfixes must never silently discard, mask, or change user data, hooks, plugin registrations, or extension points; if a migration or transformation is required, ensure it is invertible where possible and preserves optional hooks or entry points.
- Order and determinism: Any operation that outputs an ordered structure (lists, sets, dicts, serialized output, etc.) must be fully deterministic and canonical, avoiding reliance on implementation details such as hash or iteration order.
- When fixing inadequacies in code generation or code rewriting (such as AST manipulations or doc generation), ensure generated and round-tripped output remains structurally identical to what a human developer would expect, with round-trip tests for edge cases.
- In all changes, explicitly propagate undefined, error, or exceptional states and do not assume the operation can proceed with a fallback value—raise the appropriate error or preserve “undefined” sentinel values as dictated by project and mathematical conventions.
- Any new or altered logic involving introspection, hooks, or extensibility APIs must continue to delegate or respect user-overridable methods, callables, and plugin contracts, and must not unilaterally “hardcode” or shadow such points of extension.
- Data structure or state mutation during iteration must detect and raise errors as per Python's standard idioms, rather than silently accepting or attempting to continue.
- For any performance optimization or auto-detection logic, ensure it does not cause information loss, break invariants, or introduce surprising side effects for end users, especially in iterative, batched, or chained computation modes.
- Comprehensive test coverage is required for new or edge-case behaviors introduced by the patch, including round-trip scenarios and regressions for all known variations, but test logic must not become overly coupled to implementation details. 
- Each code update or fix must preserve the documented and idiomatic API for that host framework or project (Django, Scikit-Learn, SymPy, Matplotlib, Sphinx, etc.)—never change function signatures or public class inheritance without a compelling and documented technical justification.
- Never introduce redundant, unrelated, or global changes that are not strictly motivated by the core requirement or could result in maintainability challenges or cryptic regressions in unrelated modules.
- Be mindful when updating or relying on language- or platform-specific features (e.g., Python minor version features, framework-specific object protocols); provide backwards-compatible handling whenever feasible to serve users across the supported ecosystem.
- When applying deduplication, grouping, or normalization logic to user inputs or internal state, always use stable and canonical ordering and minimize the potential for data loss, regression, or ambiguity—mirror the semantics expected by users and the broader community.